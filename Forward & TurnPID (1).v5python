{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_back = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nleft_motor_middle = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nleft_motor_front = Motor(Ports.PORT13, GearSetting.RATIO_18_1, False)\nright_motor_back = Motor(Ports.PORT20, GearSetting.RATIO_18_1, True)\nright_motor_middle = Motor(Ports.PORT19, GearSetting.RATIO_18_1, True)\nright_motor_front = Motor(Ports.PORT18, GearSetting.RATIO_18_1, True)\ncontroller_1 = Controller(PRIMARY)\ninertial_9 = Inertial(Ports.PORT9)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:      1/8/2024\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n#Made By: Anderson R.\n\n# Library imports\nfrom vex import *\n\n#Make sure to change the ports\n#READ: Set kd and kp to small values or even 0, then start testing\n\n#Values will be calibrated\nglobal kd\nglobal kp\n#THIS KD & KP IS FOR GOING STRAIT (Lines 79-80 for turning kp & kd)\nkd = 0.5\nkp = 0.5\n\n#Set the Wheel data\nwheel_circumference = 260;\ndegrees_per_rotation = 360;\nglobal distance_per_degree\n\n#distance that it traveled for each degree the wheel rotated\ndistance_per_degree = wheel_circumference / degrees_per_rotation;\n\nmovement = \"Turn\"\n\n#In MM\nglobal distancee\n#\nif movement == \"Forward\":\n    distancee = 1000 * 1.04472368421;\nelse:\n    distancee = 90\n    print(\"TURN\")\n    #THIS KP & KD VALUE FOR TURNING TO THE SIDE\n    kd = 1\n    kp = 0.1\n# Begin project code\n\n\n#Might Change\nleft_motor_back.set_velocity(1, PERCENT)\nleft_motor_middle.set_velocity(1, PERCENT)\nleft_motor_front.set_velocity(1, PERCENT)\n\nright_motor_back.set_velocity(1, PERCENT)\nright_motor_middle.set_velocity(1, PERCENT)\nright_motor_front.set_velocity(1, PERCENT)\n\ndef forward_pid(distancee, kp, kd):\n    SetDegrees()\n    #This fuction moves the robot;\n    #motor speed = error * kp * (â–³error/time) * kd;\n    SetDegrees();\n    brain.timer.clear();\n    wait(5,MSEC)\n    error = distancee;\n    old_error = error;\n    time_passed = 0.005\n\n    left_motor_back.spin(FORWARD)\n    left_motor_middle.spin(FORWARD)\n    left_motor_front.spin(FORWARD)\n    right_motor_back.spin(FORWARD)\n    right_motor_middle.spin(FORWARD)\n    right_motor_front.spin(FORWARD)\n\n    #Remember to change the true until the bot has stopped\n    while True:\n        distance_traveled = float(distance_traveled_calc())\n        error = float(error)\n        error = float(distancee) - distance_traveled;\n        error_change = error - old_error;\n        if error_change < 0:\n            error_change = error_change * -1\n        old_error = error;\n\n        #Get the time\n        time_passed = float(brain.timer.time(SECONDS));\n        controller_1.screen.print(\"Time:\" + str(time_passed))\n        \n\n        #PID calculation (Nightmare)\n        error_changed = error_change / time_passed;\n        controller_1.screen.print(\"Error: \" + str(error_changed))\n        motor_speed = (error * kp) + (error_changed * kd);\n        controller_1.screen.print(motor_speed)\n\n\n        #Cap the max and min speed %\n        if motor_speed > 100:\n            motor_speed = 100;\n\n        oposite = motor_speed * -1\n        \n        #High Temp Check\n        if left_motor_back.temperature(PERCENT) >= 90 or left_motor_front.temperature(PERCENT) >= 90 or left_motor_middle.temperature(PERCENT) >= 90:\n            controller_1.screen.print(\"Left Wheels Overheating, it is highly recommended to let it cool!\")\n            brain.screen.print(\"Left Wheels Overheating, it is highly recommended to let it cool!\")\n        elif right_motor_back.temperature(PERCENT) >= 90 or right_motor_front.temperature(PERCENT) >= 90 or right_motor_middle.temperature(PERCENT) >= 90:\n            controller_1.screen.print(\"Right Wheels Overheating, it is highly recommended to let it cool!\")\n            brain.screen.print(\"Right Wheels Overheating, it is highly recommended to let it cool!\")\n\n        #Set the speed\n        if movement == \"Forward\":\n            #Going Forward\n            left_motor_back.set_velocity(motor_speed, PERCENT)\n            left_motor_middle.set_velocity(motor_speed, PERCENT)\n            left_motor_front.set_velocity(motor_speed, PERCENT)\n\n            right_motor_back.set_velocity(motor_speed, PERCENT)\n            right_motor_middle.set_velocity(motor_speed, PERCENT)\n            right_motor_front.set_velocity(motor_speed, PERCENT)\n        else:\n            #Right Turning \n            left_motor_back.set_velocity(motor_speed, PERCENT)\n            left_motor_middle.set_velocity(motor_speed, PERCENT)\n            left_motor_front.set_velocity(motor_speed, PERCENT)\n\n            right_motor_back.set_velocity(oposite, PERCENT)\n            right_motor_middle.set_velocity(oposite, PERCENT)\n            right_motor_front.set_velocity(oposite, PERCENT)\n\n        #Loop Ender - might need to fix\n        if distance_traveled == distancee:\n            break;\n\n        wait(5,MSEC)\n\n\ndef distance_traveled_calc():\n    left_front = float(left_motor_front.position(DEGREES));\n    left_middle = float(left_motor_middle.position(DEGREES));\n    left_back = float(left_motor_back.position(DEGREES));\n\n    right_front = float(right_motor_front.position(DEGREES));\n    right_middle = float(right_motor_middle.position(DEGREES));\n    right_back = float(right_motor_back.position(DEGREES));\n\n    right_movement = right_front + right_middle + right_back;\n    right_movement = right_movement * -1;\n\n    average = left_front + left_middle + left_back + right_movement;\n    average = average / 6;\n    return (average * distance_per_degree)\n\n#MAY CHANGE\ndef  TurnPID():\n    brain.timer.clear();\n    wait(5,MSEC);\n    error = 90;\n    old_error = error;\n    time_passed = 0.005\n\n\ndef SetDegrees():\n    left_motor_back.set_position(0, DEGREES);\n    left_motor_middle.set_position(0, DEGREES);\n    left_motor_front.set_position(0, DEGREES);\n\n    right_motor_back.set_position(0, DEGREES);\n    right_motor_middle.set_position(0, DEGREES);\n    right_motor_front.set_position(0, DEGREES);\n\n\nforward_pid(distancee, kp, kd)\n\n#forward_pid(distancee, kp, kd)","textLanguage":"python","rconfig":[{"port":[11],"name":"left_motor_back","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[12],"name":"left_motor_middle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[13],"name":"left_motor_front","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[20],"name":"right_motor_back","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[19],"name":"right_motor_middle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[18],"name":"right_motor_front","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[9],"name":"inertial_9","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":6,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}